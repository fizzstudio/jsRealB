/// load system tools
import { existsSync, statSync, readFileSync, writeFileSync } from 'fs';
import { spawnSync } from 'child_process';
import path from 'path';
import { fileURLToPath } from 'url';

//////// 
//  load JSrealB
let {default:jsRealB} = await import("../../dist/jsRealB.js");
Object.assign(globalThis,jsRealB);


//////
//  load regenerator classes
import { parseUDs } from "../UDregenerator/UDregenerator.js";

import { fixPunctuation } from "../UDregenerator/utils.js";

const dir = "/Users/lapalme/Documents/GitHub/jsRealB/demos/Bilinguo/data/"
const file = "sentences"

function createCONLLUfile(lang,fileName){
    const conlluFileName=fileName.replace(/.txt$/,".conllu")
    if (!existsSync(conlluFileName) || statSync(conlluFileName).mtime<statSync(fileName).mtime){
        console.log("*** Creating %s",conlluFileName)
        // create conllu file
        const __filename = fileURLToPath(import.meta.url);
        const __dirname = path.dirname(__filename);
        const child = spawnSync(`${__dirname}/text2ud-new.py`,[lang, fileName],{"stdio":"inherit"})
        if (child.status==0){
            console.log("*** Wrote  %s",conlluFileName);
        } else {
            console.log('*** Problem in file creation:' +`code ${code} and signal ${signal}`);
        }
    } else {
        console.log(fileName+" is up to date")
    }
}

function makeCONLLUfiles(enfrFileName){
    let m = /(.*)-en-fr\.txt/.exec(enfrFileName)
    if (m===null){
        console.log('File name should en in "en-frameElement.txt":'+enfrFileName)
        return;
    }
    if (!existsSync(m[1]+"-en.txt") || statSync(m[1]+"-en.txt").mtime<statSync(enfrFileName).mtime){
        const en_fr_lines=readFileSync(enfrFileName,"utf-8").split("\n");
        const en_lines=[],fr_lines=[];
        for (let en_fr_line of en_fr_lines){
            const [en_line,fr_line]=en_fr_line.split("\t")
            en_lines.push(en_line);
            fr_lines.push(fr_line);
        }
        writeFileSync(m[1]+"-en.txt",en_lines.join("\n"));
        createCONLLUfile("en",m[1]+"-en.txt");
        writeFileSync(m[1]+"-fr.txt",fr_lines.join("\n"));
        createCONLLUfile("fr",m[1]+"-fr.txt");
    } else {
        console.log(enfrFileName+" is up to date")
    }
}

async function parseCONLLU(lang,fileName){
    await import(`../UDregenerator/UDregenerator-${lang}.js`);
    const conllu =  readFileSync(fileName, 'utf8');
    const uds=parseUDs(conllu);
    let structs = [];
    load(lang);
    for (let ud of uds){
        // remove ending full stop, it will be regenerated by jsRealB
        const udRoot=ud.root;
        if (udRoot.right.length>0){
            let lastIdx=udRoot.right.length-1;
            if (udRoot.right[lastIdx].deprel=="punct" && udRoot.right[lastIdx].lemma=="."){
                udRoot.right.splice(lastIdx,1)
            }
        }
        const jsrExpr=ud.root.toDependent(false,false);
        if (!jsrExpr.isA("root"))
            jsrExpr.constType="root"
        if (jsrExpr.terminal.isA("V"))  // remove properties from the root verb
            jsrExpr.terminal=V(jsrExpr.terminal.lemma);
        structs.push({
            text:jsrExpr.clone().realize(lang),
            id:ud.sent_id,
            jsr:jsrExpr.toSource(12)
        });
    }
    return structs;
}

// import "../UDregenerator/UDregenerator-en.js";
makeCONLLUfiles(dir+file+"-en-fr.txt")
const structs_en=await parseCONLLU("en",dir+file+"-en.conllu");

// import "../UDregenerator/UDregenerator-fr.js";
const structs_fr=await parseCONLLU("fr",dir+file+"-fr.conllu");

let structs = [];
for (let i=0;i<structs_en.length;i++){
    const en=structs_en[i];
    const fr=structs_fr[i];
    let struct = `{
    id: ${en.id},
    text: "${fr.text+" | "+en.text}",
    fr : ()=>
            ${fr.jsr},
    en : ()=>
            ${en.jsr},
    params:[]
}`;
    structs.push(struct);
}

writeFileSync(dir+file+'-en-fr.js',"const "+file+"=[\n"+structs.join(",\n")+"];",'utf-8')
console.log(dir+file+'-en-fr.js'+" written")
